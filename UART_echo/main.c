#include <stdint.h>
#include "stm32h7xx_hal.h"
#include "stm32h7xx_nucleo.h"

void SystemClock_Config(void);
void GPIO_Init(void);
void USART3_UART_Init(void);

UART_HandleTypeDef huart3;

int main(void) {
    HAL_MPU_Disable();
    HAL_Init();
    SystemClock_Config();

    GPIO_Init();
    USART3_UART_Init();

    const uint8_t BUF_SZ = 10;
    uint8_t rcv[BUF_SZ];
    const unsigned char NEWLINE = '\n';
    uint8_t idx = 0;

    while (1) {
        /* Handle received data byte by byte */
        if (HAL_UART_Receive(&huart3, &rcv[idx], 1, HAL_MAX_DELAY) == HAL_OK) {
            /* Toggle LED to signal character reception */
            HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);

            /* Echo the received character back out */
            HAL_UART_Transmit(&huart3, &rcv[idx], 1, HAL_MAX_DELAY);

            /* Add a newline after each carriage return */
            if (rcv[idx] == '\r') {
                HAL_UART_Transmit(&huart3, &NEWLINE, 1, HAL_MAX_DELAY);
            }

            /* We have received BUF_SZ characters, so reset */
            if (idx == BUF_SZ - 1) {
                idx = 0;
            } else {
                idx++;
            }
        }
    }
}

/*
 * SysTick interrupt handler, needed for delays
 *
 * By default, an interrupt is generated every 1ms by the SysTick timer, which
 * calls this function. The HAL_delay() function checks a global variable to see
 * if the ms value passed to it has been reached. Here we increment that
 * variable by 1. Without this, the delay will just be an infinite loop.
 */
void SysTick_Handler(void)
{
    HAL_IncTick();
}

/* Initialize GPIO B pins 0 and 14 (for LEDs 1 and 3) */
void GPIO_Init(void) {
    __HAL_RCC_GPIOB_CLK_ENABLE();

    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_14;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

/* Custom error handler, turns on the orange LED and loops infinitely */
void Error_Handler(void) {
    BSP_LED_Init(LED2);
    BSP_LED_On(LED2);
    while (1) {
        // Stay here
    }
}

/* Initialize UART clock, pins, and parameters */
void USART3_UART_Init(void) {
    RCC_PeriphCLKInitTypeDef RCC_PeriphClkInit;
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    // Enable GPIO clocks for USART3 TX and RX
    __HAL_RCC_GPIOD_CLK_ENABLE();

    // Enable USART3 clock
    __HAL_RCC_USART3_CLK_ENABLE();

    // Configure USART3 TX (PD8) and RX (PD9)
    GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

    // Configure UART parameters
    huart3.Instance = USART3;
    huart3.Init.BaudRate = 115200;
    huart3.Init.WordLength = UART_WORDLENGTH_8B;
    huart3.Init.StopBits = UART_STOPBITS_1;
    huart3.Init.Parity = UART_PARITY_NONE;
    huart3.Init.Mode = UART_MODE_TX_RX;
    huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart3.Init.OverSampling = UART_OVERSAMPLING_16;

    if (HAL_UART_Init(&huart3) != HAL_OK) {
        // Initialization Error
        Error_Handler();
    }
}


/* Clock setup, generated by CubeMX */
void SystemClock_Config(void)
{
    RCC_ClkInitTypeDef RCC_ClkInitStruct;
    RCC_OscInitTypeDef RCC_OscInitStruct;
    HAL_StatusTypeDef ret = HAL_OK;

    /*!< Supply configuration update enable */
    HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);

    /* The voltage scaling allows optimizing the power consumption when the device is
       clocked below the maximum system frequency, to update the voltage scaling value
       regarding system frequency refer to product datasheet.  */
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}

    /* Enable HSE Oscillator and activate PLL with HSE as source */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
    RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
    RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
    RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;

    RCC_OscInitStruct.PLL.PLLM = 4;
    RCC_OscInitStruct.PLL.PLLN = 400;
    RCC_OscInitStruct.PLL.PLLFRACN = 0;
    RCC_OscInitStruct.PLL.PLLP = 2;
    RCC_OscInitStruct.PLL.PLLR = 2;
    RCC_OscInitStruct.PLL.PLLQ = 4;

    RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
    RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_1;
    ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
    if(ret != HAL_OK)
    {
      Error_Handler();
    }

    /* Select PLL as system clock source and configure  bus clocks dividers */
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 | \
                                   RCC_CLOCKTYPE_PCLK2  | RCC_CLOCKTYPE_D3PCLK1);

    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
    RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
    RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
    ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
    if(ret != HAL_OK)
    {
      Error_Handler();
    }

    /* Activate CSI clock mandatory for I/O Compensation Cell */
    __HAL_RCC_CSI_ENABLE() ;

    /* Enable SYSCFG clock mandatory for I/O Compensation Cell */
    __HAL_RCC_SYSCFG_CLK_ENABLE() ;

    /* Enables the I/O Compensation Cell */
    HAL_EnableCompensationCell();
}
