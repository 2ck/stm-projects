#include <stdint.h>
#include "stm32h7xx_hal.h"
#include "stm32h7xx_nucleo.h"
#include "SparkFun_GridEYE_Arduino_Library.h"
#include "debug.h"

void SystemClock_Config(void);
void GPIO_Init(void);
void USART3_UART_Init(void);

UART_HandleTypeDef huart3;

void Error_Handler();

float temps[64];

void get_temps() {
    for (int i = 0; i < 64; i++) {
        temps[i] = GridEYE_getPixelTemperature(i);
    }
}

void print_temps() {
    /* Clear screen and move cursor to home position */
    print("\033[2J\033[H");
    for (int i = 0; i < 64; i++) {
        print("%f, ", temps[i]);
        if (i % 8 == 7)
            print("\r\n");
    }
}

void visualize_temps() {
    /* Clear screen and move cursor to home position */
    print("\033[2J\033[H");
    for (int i = 0; i < 64; i++) {
        char c = '.';
        if (temps[i] > 20)
            c = 'o';
        if (temps[i] > 25)
            c = '0';
        if (temps[i] > 30)
            c = 'O';
        print("%c", c);
        if (i % 8 == 7)
            print("\r\n");
    }
}

int main(void) {
    HAL_MPU_Disable();
    HAL_Init();
    SystemClock_Config();

    GPIO_Init();
    USART3_UART_Init();

    GridEYE_begin();

    BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);

    while (1) {
        get_temps();
        if (BSP_PB_GetState(BUTTON_USER) == BUTTON_PRESSED) {
            print_temps();
        }
        /* Give the sensor some rest time */
        HAL_Delay(100);
    }
}

/*
 * SysTick interrupt handler, needed for delays
 *
 * By default, an interrupt is generated every 1ms by the SysTick timer, which
 * calls this function. The HAL_delay() function checks a global variable to see
 * if the ms value passed to it has been reached. Here we increment that
 * variable by 1. Without this, the delay will just be an infinite loop.
 */
void SysTick_Handler(void)
{
    HAL_IncTick();
}

/* Initialize GPIO B pins 0 and 14 (for LEDs 1 and 3) */
void GPIO_Init(void) {
    __HAL_RCC_GPIOB_CLK_ENABLE();

    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_14;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

/* Custom error handler, turns on the orange LED and loops infinitely */
void Error_Handler(void) {
    BSP_LED_Init(LED2);
    BSP_LED_On(LED2);
    while (1) {
        // Stay here
    }
}

/* Initialize UART clock, pins, and parameters */
void USART3_UART_Init(void) {
    RCC_PeriphCLKInitTypeDef RCC_PeriphClkInit;
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    // Enable GPIO clocks for USART3 TX and RX
    __HAL_RCC_GPIOD_CLK_ENABLE();

    // Enable USART3 clock
    __HAL_RCC_USART3_CLK_ENABLE();

    // Configure USART3 TX (PD8) and RX (PD9)
    GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

    // Configure UART parameters
    huart3.Instance = USART3;
    huart3.Init.BaudRate = 115200;
    huart3.Init.WordLength = UART_WORDLENGTH_8B;
    huart3.Init.StopBits = UART_STOPBITS_1;
    huart3.Init.Parity = UART_PARITY_NONE;
    huart3.Init.Mode = UART_MODE_TX_RX;
    huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart3.Init.OverSampling = UART_OVERSAMPLING_16;

    if (HAL_UART_Init(&huart3) != HAL_OK) {
        // Initialization Error
        Error_Handler();
    }
}


/* Clock setup, generated by CubeMX */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    /** Supply configuration update enable
    */
    HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);

    /** Configure the main internal regulator output voltage
    */
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);

    while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}

    /** Initializes the RCC Oscillators according to the specified parameters
    * in the RCC_OscInitTypeDef structure.
    */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
    RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
    RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLM = 1;
    RCC_OscInitStruct.PLL.PLLN = 24;
    RCC_OscInitStruct.PLL.PLLP = 2;
    RCC_OscInitStruct.PLL.PLLQ = 4;
    RCC_OscInitStruct.PLL.PLLR = 2;
    RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
    RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
    RCC_OscInitStruct.PLL.PLLFRACN = 0;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
    {
        Error_Handler();
    }

    /** Initializes the CPU, AHB and APB buses clocks
    */
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                                  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                                  |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
    RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
    RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;

    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
    {
        Error_Handler();
    }
}
